---
marp: true
theme: iggg
paginate: true
---
<!-- mermaid.js  Для схем -->
<script src="https://unpkg.com/mermaid@8.1.0/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>
<!-- _class: lead -->

# Задача об обедающих философах

---
# Условие

![bg fit right:36%](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/800px-An_illustration_of_the_dining_philosophers_problem.png)

Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. Вилки лежат на столе между каждой парой ближайших философов.

Каждый философ может либо **есть**, либо **размышлять**. Философ может есть только тогда, когда держит две вилки — взятую справа и слева.

Вопрос задачи заключается в том, чтобы разработать **модель поведения**, где все философы будут вечно чередовать приём пищи и размышления. 

---

# Задача

* Симуляция философов на системных потоках
* Расширить задачу до `N` философов
* Написать алгоритм для `N` потоков с доступом к общим данным без гонки данных.

---

# Основа решения

Структура философа и алгоритм поведения

```rust
struct Philosopher {
    id: usize, 
    first: Arc<Mutex<usize>>,  // ссылка на первую вилку
    second: Arc<Mutex<usize>>, // ссылка не вторую вилку
}

pub fn eat(&mut self) {
    loop {
        let first = self.first.lock().unwrap();   // берем вилку первую
        let second = self.second.lock().unwrap(); // берем вилку вторую
        drop(second);
        drop(first);
        thread::sleep(Duration::from_nanos(1)); //поел
    }
}
```

---

# Запуск потоков

```rust
pub fn dining<const N: usize>(f: impl Fn(usize) -> TakeFirst) {
    let forks: Vec<Fork> = (0..N).map(|i| Arc::new(Mutex::new(i))).collect();
    let phs: Vec<_> = (0..N)
        .map(|id| Philosopher::new(id, &forks[id], &forks[(id + 1) % N], f(id)))
        .map(|mut ph| {
            thread::spawn(move || {
                ph.eat();
                ph
            })
        })
        .collect::<Vec<_>>()
        .into_iter()
        .map(|th| th.join().unwrap())
        .collect();
}
```

---

# Простой подход

На первый взгляд, нужно заставить каждого философа дождаться доступности **левой** вилки, взять её, дождаться доступности **правой** вилки, взять ее, поесть и положить обе вилки на стол. 

Возникает проблема что с большой вероятностью все философы остаются с левыми вилками и возникает **deadlock**
```rust
dining::<N>(|_| TakeFirst::Left);
```
---

# Решение

Мы можем изменить одного философа *правшой* и он будет предпочитать первой брать правую вилку.

Это решение предотвращает проблему **deadlock**. Но распределение еды на каждого философа может быть неравномерным.

```rust
dining::<N>(|i| {
    if i == 0 {
        TakeFirst::Left
    } else 
        TakeFirst::Right
    }
})
```

---

# Равномерное решение

Что-бы добиться равного распределения среди философов можно определить пронумеровать философов от `1` до `N` и задать алгоритм где **чётные** философы берут **левую** вилку, а **нечетные** берут **правую**.

```rust
dining::<N>(|i| {
    if i % 2 == 0 {
        TakeFirst::Left
    } else {
        TakeFirst::Right
    }
});
```

---

# Замеры данных

Выполняем замер на минуту для каждого метода

| id | Один правша | Четные правши |
| -  | -           | -      |
| 0  | 19.9986 %   | 20.0%  |
| 1  | 19.9916 %   | 20.0%  |
| 2  | 20.0004 %   | 20.0%  |
| 3  | 20.0039 %   | 20.0%  |
| 4  | 20.0056 %   | 20.0%  |

*Простой метод не закончил работу*

---

# Заключение

Задача философов является отличным примером для изучения синхронизации в параллельных алгоритмах. 



